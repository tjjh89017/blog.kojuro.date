[{"categories":["life"],"content":"如何用Viber Out打電話時可以正確地送出數字鍵功能 ","date":"2025-09-22","objectID":"/2025/09/20250922-viber-out-dtmf/:0:0","tags":["life","hack","viber","dtmf"],"title":"如何用Viber Out打電話時可以正確地送出數字鍵功能","uri":"/2025/09/20250922-viber-out-dtmf/"},{"categories":["life"],"content":"緣起 朋友被卡在冰島/荷蘭，但是中華航空的台灣客服打不進去，打給我請我幫忙，然後想說嘗試其他國家的華航客服看看，用Skype Dial可以打出去並輸入數字鍵功能一陸轉接到客服，但是這個已經沒辦法儲值了，只剩下Viber可以儲值Viber Out來打國際電話，但是遇到Viber Out打去香港華航的時候，輸入數字鍵怎麼書都會被系統回應錯誤輸入，才跑去研究DTMF的功能機制。 ","date":"2025-09-22","objectID":"/2025/09/20250922-viber-out-dtmf/:1:0","tags":["life","hack","viber","dtmf"],"title":"如何用Viber Out打電話時可以正確地送出數字鍵功能","uri":"/2025/09/20250922-viber-out-dtmf/"},{"categories":["life"],"content":"DTMF 根據此篇文，DTMF有不同種類的形式，有些是直接給訊號，有些是直接幫你在語音內插入數字頻率，那DTMF最早期的玩法就是直接透過同一個語音通道直接給出特定頻率音訊，讓對面設備聽到相關的音頻來選擇功能。所以這邊可以直接對手機麥克風撥放DTMF code，達成相同目的。通常對應對方為老舊設備的時候使用。 ","date":"2025-09-22","objectID":"/2025/09/20250922-viber-out-dtmf/:2:0","tags":["life","hack","viber","dtmf"],"title":"如何用Viber Out打電話時可以正確地送出數字鍵功能","uri":"/2025/09/20250922-viber-out-dtmf/"},{"categories":["life"],"content":"實際操作 請準備另外一個可以播放聲音的設備，並將音量調大聲一點 開啟此網頁 https://onlinetonegenerator.com/dtmf.html 或尋找相關DTMF Tone Generator Viber Out在原本手機上撥號 聽到電話內的提示選項(例如這邊要選1進入中文模式) 則在另外一個設備上稍微長按數字1，讓該音頻撥放稍微久一點，並傳入Viber的手機的麥克風 你就成功輸入了1到對方系統上了 有點蠢，但是會動。分享給有需要的朋友們 ","date":"2025-09-22","objectID":"/2025/09/20250922-viber-out-dtmf/:3:0","tags":["life","hack","viber","dtmf"],"title":"如何用Viber Out打電話時可以正確地送出數字鍵功能","uri":"/2025/09/20250922-viber-out-dtmf/"},{"categories":["hack"],"content":"記錄怎麼把有ARccOS保護的DVD備份起來 ","date":"2025-09-21","objectID":"/2025/09/2025-09-21-dvd-ripper/:0:0","tags":["life","dvd","ripper"],"title":"記錄怎麼把有ARccOS保護的DVD備份起來","uri":"/2025/09/2025-09-21-dvd-ripper/"},{"categories":["hack"],"content":"緣由 我跑去日本買了一些DVD回台灣，然後想要把它們備份起來到NAS裡面，畢竟我常用的電腦是沒有光碟機的。但是就遇到ARccOS類型的保護，讓光碟機其實可以撥放，但是就沒有辦法備份，所以有了這篇文。 ","date":"2025-09-21","objectID":"/2025/09/2025-09-21-dvd-ripper/:1:0","tags":["life","dvd","ripper"],"title":"記錄怎麼把有ARccOS保護的DVD備份起來","uri":"/2025/09/2025-09-21-dvd-ripper/"},{"categories":["hack"],"content":"感謝 目前看到最成功的方案就是使用這篇文提到的方案，但是我後續有嘗試其他種類讓成功率更高，效率相對也會高義點的方案。 ","date":"2025-09-21","objectID":"/2025/09/2025-09-21-dvd-ripper/:2:0","tags":["life","dvd","ripper"],"title":"記錄怎麼把有ARccOS保護的DVD備份起來","uri":"/2025/09/2025-09-21-dvd-ripper/"},{"categories":["hack"],"content":"步驟 先用ddrescue把資料盡可能複製出來，而且強調一下，最好用-R的參數，讓他從後面往前讀，成功率相對比較高 ddrescue -n -b 2048 -N -d -R -r3 -c512 /dev/sr0 output.iso output.log 然後再用ddrescue正向走一次整個流程，把bad sector盡量複製出來 ddrescue -n -b 2048 -N -d -r3 -c512 /dev/sr0 output.iso output.log 或是 ddrescue -b 2048 -d -r3 -c1 /dev/sr0 output.iso output.log 基本上這樣你就會得到一個相對可用的output.iso，然後你可以導入你其他的DVD Ripper或是直接存起來了。 ","date":"2025-09-21","objectID":"/2025/09/2025-09-21-dvd-ripper/:3:0","tags":["life","dvd","ripper"],"title":"記錄怎麼把有ARccOS保護的DVD備份起來","uri":"/2025/09/2025-09-21-dvd-ripper/"},{"categories":["hack"],"content":"其他 ","date":"2025-09-21","objectID":"/2025/09/2025-09-21-dvd-ripper/:4:0","tags":["life","dvd","ripper"],"title":"記錄怎麼把有ARccOS保護的DVD備份起來","uri":"/2025/09/2025-09-21-dvd-ripper/"},{"categories":["hack"],"content":"binwalk 如果沒辦法直接把ISO打開放PotPlayer播放，那就可能要靠binwalk把VOB直接取出來 binwalk -e --dd='mpeg' output.iso ","date":"2025-09-21","objectID":"/2025/09/2025-09-21-dvd-ripper/:4:1","tags":["life","dvd","ripper"],"title":"記錄怎麼把有ARccOS保護的DVD備份起來","uri":"/2025/09/2025-09-21-dvd-ripper/"},{"categories":null,"content":"About Date Huang","date":"2025-03-24","objectID":"/about/","tags":null,"title":"About Date Huang","uri":"/about/"},{"categories":null,"content":"Just a software engineer Resume 20250324 is here ","date":"2025-03-24","objectID":"/about/:0:0","tags":null,"title":"About Date Huang","uri":"/about/"},{"categories":["life"],"content":"簡單記錄下在VyOS Networks上班的第一年 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:0:0","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"在這之前 其實我大概在大學跟碩士的時候，其實就已經在用VyOS好一陣子了。那時候在弄DozenCloud的時候因為一些原因，所以需要各種打Tunnel到不同地方，最原本是用pfSense來做一些NAT gateway等等的工作，但是pfSense對於Policy Based Routing沒有說很容易，也沒辦法正確處理，所以就google發現到VyOS是一個完整的Linux based Router，就拿來用了。在Edgecore上班的時候，也會把VyOS拿來測試一些行為啥的。測試跟使用的過程總是會遇到一些bug，也因為是開源的專案，所以我也就順便幫他們修了三四個bug過。總之就用了五年起跳吧。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:1:0","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"怎麼會進VyOS 2023年的時候，我從前公司離職休息了半年多吧，找工作也沒說很順利，滿多工作都碰壁，也不是很確定自己的職涯發展要往哪個職位走，畢竟我從Presales跑到Software Engineer，用著Presales的角度看軟體開發，有時候滿微妙的，如果專案本身的走向怪怪了話。 那個時間點，我跟Jalen沒事幹在嘗試把VyOS弄上Raspberry Pi的環境上執行，真的搞出來之後，貼到Linkedin上面宣傳一下，順便當找工作用的宣傳。 不知道是不是去媽祖廟跟土地公廟祈求個合適的工作，我的Linkedin被VyOS的老闆看到了，剛好VyOS需要一個Presales Engineer來幫業務們一些技術上的問題，而不用太花RD跟Support的時間，同時間VyOS正在思考跟一些硬體廠商合作，也需要一個曾經在硬體廠也懂一些硬體相關的工程師，這樣聽完我還真的滿合適的角色，畢竟我之前也是做了一堆奇怪的事情。 VyOS老闆就跟我約了一個時間通了一通電話，他在西班牙馬德里，而我在台灣，就聊聊這個職缺的需求跟情況，然後就安排了第二次面試了。第二次面試的面試官有CTO、RD跟Support頭、業務主管，不過講話的幾乎只有RD跟Support的主管跟我問一些問題這樣，說是問問題，我感覺比較像是聊天，因為他就是用各種情境問我會怎麼處理這樣，說實在的我現在覺得這個面試經驗一點參考價值也沒有，感覺他們看我介紹我自己的side project，然後看了下我的Github之後，剩下就是看我的反應適不適合當Presales而已。不過我面試的時候得失心滿重的，因為那時候真的有興趣的沒開缺，不然就是已經把我刷了，因為我不是Software Engineer。 我個人是滿意外會通過這個面試，因為除了RD頭之外，其他人一句話都沒講過，讓我滿緊張的，畢竟有講話會知道對方情緒跟態度，但是沒講話就完全沒辦法猜測了。後來就進入簽約跟談薪水的階段，VyOS也很好的讓我可以再多休一個月，後來就選擇9月1日上班了，工作本身就全遠端模式了。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:2:0","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"VyOS工作型態 進去VyOS之後，發現公司其實算是一個新創，人數沒有很多，加起來才50人上下而已，而且沒半個人會進辦公室，因為住在辦公室附近的，只有一個系統工程師而已，他沒事也不進去。然後東亞只有我一個人，所以我就把自己的上班時區平移到接近歐洲時區了，還有幾個同事在阿根廷，直接跟台灣時區接近日夜顛倒。算是滿彈性的遠端工作，沒有特定時間要在線上，也沒有要求在哪個地點上班。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:3:0","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"一些工作上的趣事 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:4:0","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"真遠端工作 剛進去的時候，公司指派RD頭當我的入職導師，來帶我的入職的狀態這樣。因為是遠端工作，他也說工作真的很彈性不太要求。我剛好聽朋友提到華航福岡的機票大特價，我就訂了一張機票飛到福岡的機票，周五下午飛，下下周一飛回台灣，總共十天的計畫這樣。跟導師提這件事的時候，說我會早上去玩，晚上工作，畢竟日本晚上時間剛好歐洲上班時間，他就對我說了句：OK啊，我們很彈性的，你在哪上班我們沒有差，反正我們原本原則就是不會預期大家固定的回應時間，總是大家有自己的私事可能會晚點回應什麼的。 後來我也用這個方式，在日本一邊玩好幾天一邊工作好幾天，畢竟我可以有兩個周末在日本放假，雖然機票跟飯店會貴一點。順帶一提，我有一位在日本上班的學弟，他回台灣的時間點，我會跑去他家睡，直接省飯店錢。 還有個有趣的故事，主管主要在西班牙，某天請了兩天假，然後就跟我們說他在峇里島上班兩周，記得用峇里島時區找他，後來他又請假兩天，我們就知道他飛回西班牙了。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:4:1","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"跟硬體一些合作案 公司突然發現很多他們想要合作的硬體廠，其實總部都在台灣，他們就全部把台灣相關的合作夥伴全部丟給我全權處理，還在會議上的時候跟我說：你可以直接講中文喔，有需要我的時候再用英文跟我講就可以了。不過也因為可以講中文，我很多時後直接打電話給對方快速問一些問題，對方也直接打給我快速問問題，有滿多事件就很快的可以處理過去，而不用信件慢慢來回。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:4:2","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"聯繫台灣的客戶 業務主管那邊發現某個台灣客戶用VyOS用了很兇而且買了不少加值服務的方案，但從來沒用過那些加值服務，就很好奇是不是客戶不知道有這些服務，但是他們又從email裡面沒辦法聯繫上對方，就問問我有沒有機會找到對方窗口聯繫看看，我就剛好有幾個學弟跟朋友在該公司任職，就打了幾通電話去問這件事，學弟還真的在他們內部系統裡面找到我們公司產品的一些使用說明，然後還真的找到跟我們下單的單位負責人了，覺得這個真的是有夠神奇的路徑。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:4:3","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"有趣的出包? 說釋出包，但某程度不完全算是我的錯，而是各種溝通誤會疊加之後變成的。這件事發生的時候我剛好在東京，然後太緊急了，直接在東京車站外面，大家常拍照的地方開會，總之最後我發現了這個溝通誤會，業務主管跟技術主管都一致認為我的必要性了，因為大家預設的立場跟選擇不一樣，直接導致了大家的共識不是真的共識，因為有一堆誤會。有趣的點在於我人剛好在東京車站，我還不在飯店，非常克難的一起解決這問題了。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:4:4","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"聖誕節 幾乎同事都是歐洲美洲地區的，所以聖誕假期是他們最長的假期了，除了輪班的人員之外，全部放假去了。我想找人問個問題也找不到。也遇到有人直接輪班聖誕連假期間，然後下周直接休整周掉。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:4:5","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"提醒我休假的人資 因為我們公司的規定的緣故，每年的特休是無法變現或是延長使用期限的，所以一定要在該年度使用完畢，所以大概6月的時候，人資跟我說我必須要在幾月幾號開始休假到8/31號，才會用光所有特休，不然就是浪費。同時，因為我們公司沒有加班費，所以人資就直接說我們強烈建議別加班，有一個月我的上班時數確實超過不少，人資就跟我提醒，請不要超時太多，不然很容易burn out的。 我拿這兩件事跟我朋友分享的時候，每個人都覺得很羨慕也覺得很三小。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:4:6","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"外商的工作壓力 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:5:0","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"身兼多責 因為公司比較小，所以一個人會直接擔上滿多責任的，像我的角色也就很混合。一般人可能會覺得很難專注，因為一直被不同事件打斷。雖然我個人已經習慣這種狀態，但是相對也比較耗費精力跟體力。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:5:1","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"隨時被裁員 畢竟我們是直接跟美國公司簽約的，隨時都可以裁員。基本上績效不夠的情況，就會被裁掉吧。雖然我確定現在我具有一定的重要性，但是被裁員的壓力可沒因此而消失過。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:5:2","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"沒有附近的同事 因為台灣只有我一個人，所以沒有什麼距離很近的同事可以當朋友，聊聊公司八卦，幹幹公司問題這種的發洩。某程度上我都還是跟我錢公司的同事們在聊這些議題。也會跟現在同事的距離感稍微遠一點。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:5:3","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"心理健康 這個比較偏遠端工作的問題，我回台中鄉下老家遠端工作，也離開我原本的社交圈，距離社交圈也超遠，畢竟台中鄉下的交通實在不怎樣，來回移動起來基本上就是半天，台北住宿又很貴，所以變成說社交生活大幅下降，要約要幹嘛都會很懶，原本已經夠懶了，現在變得更懶。跟我更常碰面的朋友可能還會是在東京的朋友，因為我去台北的原因好幾次是因為要去松山機場飛日本。 如果房間沒辦法區分生活跟上班的區域，大腦就更難切換上下班狀態，放鬆跟休息也變得相對得更困難。所以其實一直有打算搬去台北，但是租屋市場太貴，而省下來的房租真的太香了，就變成一直沒有硬需求搬家了。 工作壓力是比一般情況更大的，很多時候沒辦法面對面，沒辦法讀空氣，我本身又相對比較工作狂跟焦慮傾向，就變成相對更負面解讀一些情況。不過還好主管每次文字基上都有使用比較明顯且明確的表達，比較不容易誤解。 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:5:4","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["life"],"content":"後記 其實今天(9/3)是我任職滿一年的年度檢驗，才剛跟主管還有人資開完會，開會前一天人資就發了主管給我的評價給我檢視，然後我發現我有幾項缺失，就讓我直接焦慮到睡不好，雖然其他部分都是很符合期待的，但就覺得不踏實。直到今天跟主管開完會看完回顧，他表示公司的「符合期待」的標準是很高的，他說就大概是10分滿分有9分的情況，這才讓我踏實不少，雖然我開會前就知道我不太可能被裁員，因為開會前一天才被指派一個9月跟10月的工作，要被裁員兩周後就不見了，不可能等兩個月的。 雖然薪資沒辦法跟Google台灣以及台積電比，但是彈性真的很很足。也因為公司規模比較小，能跨的就很多，我也有跨到RD那邊提供他們一些有趣的新想法跟幫忙解一些bug。 但不知道為什麼，現在在這間公司時間流動變得有點緩慢，我八月在日本三周，一周遠端工作，兩周使用特休，那三周的體感比過去都還要來的長，長到我三四天會打開公司的Slack看一下的情況，因為總覺得好像我應該已經結束假期。 希望未來安好 ","date":"2024-09-03","objectID":"/2024/09/2024-09-03-first-year-in-vyos/:6:0","tags":["life"],"title":"在VyOS上班的第一年","uri":"/2024/09/2024-09-03-first-year-in-vyos/"},{"categories":["linux","arm","arm64"],"content":"快速記錄下 Raspberry Pi 4 的 Console/UART 等等的三小問題 ","date":"2023-08-26","objectID":"/2023/08/2023-08-26-raspberry-pi-4-console/:0:0","tags":["arm","arm64","console","raspberrypi","linux"],"title":"Raspberry Pi 4 Console","uri":"/2023/08/2023-08-26-raspberry-pi-4-console/"},{"categories":["linux","arm","arm64"],"content":"Raspberry Pi 4 rpi4 的 console 是有兩個 UART 來選擇，讓你可以接到實體的 GPIO 腳位上面，透過 TTL 來看 console BCM2711 上面有兩個主要的 UART，我們這邊用 device tree 上面的命名，分別是： uart0: pl011,0xfe201000 (rpi4 預設開啟且連接到藍牙模組上， kernel 內是 ttyAMA0) uart1: uart8250,mmio32,0xfe215040 (rpi4 預設開啟且連接到 GPIO 14,15， kernel 內是 ttyS0) 所以現在要思考成，我們有一個可以修改 uart0/1 的路線，分別到 GPIO 14,15 或是藍牙模組上面 ","date":"2023-08-26","objectID":"/2023/08/2023-08-26-raspberry-pi-4-console/:1:0","tags":["arm","arm64","console","raspberrypi","linux"],"title":"Raspberry Pi 4 Console","uri":"/2023/08/2023-08-26-raspberry-pi-4-console/"},{"categories":["linux","arm","arm64"],"content":"Device Tree Overlay (dt-overlay) rpi4 這邊透過 config.txt 來設定 dt-overlay ，來切換不同的設定 預設情況下，rpi4 的 kernel cmdline 應該要設定成： console=ttyS0 earlycon=uart8250,mmio32,0xfe215040 例如說，如果在 config.txt 設定 dt-overlay=disable-bt ，那這樣 rpi4 會將 uart1 以及藍牙模組關閉，並將 uart0 開啟接上 GPIO 14,15，這時候的 Kernel cmdline 就需要設定成： console=ttyAMA0 earlycon=pl011,0xfe201000 另外一種是設定 uart0 為 GPIO 14,15，然後 uart1 跟藍牙模組對接，這時候要選擇 dt-overlay=miniuart-bt，這時候的 Kernel cmmdline 就需要設定成： console=ttyAMA0 earlycon=pl011,0xfe201000 ","date":"2023-08-26","objectID":"/2023/08/2023-08-26-raspberry-pi-4-console/:2:0","tags":["arm","arm64","console","raspberrypi","linux"],"title":"Raspberry Pi 4 Console","uri":"/2023/08/2023-08-26-raspberry-pi-4-console/"},{"categories":["linux","arm","arm64"],"content":"RPI4 uart 8250 額外訊息 rpi4 kernel 預設 CONFIG_SERIAL_8250_RUNTIME_UARTS 是 0 ，但是 Debian Kernel 預設是 4，所以在有些情況下需要用 cmdline 設定 8250.nr_uarts=1 或是 8250.nr_uarts=4 ","date":"2023-08-26","objectID":"/2023/08/2023-08-26-raspberry-pi-4-console/:3:0","tags":["arm","arm64","console","raspberrypi","linux"],"title":"Raspberry Pi 4 Console","uri":"/2023/08/2023-08-26-raspberry-pi-4-console/"},{"categories":["linux","arm","arm64"],"content":"RPI4 預設 pl011 連接到 bcm43438-bt rpi4 預設 pl011 直接在 device tree [4] 設定對點是 bcm43438-bt ，所以在 Linux kernel 載入的時候會透過 udev 直接掃描成藍牙裝置，systemctl 的結果就會顯示如下： sys-devices-platform-soc-fe201000.serial-serial0-serial0\\x2d0-bluetooth-hci0.device ... sys-subsystem-bluetooth-devices-hci0.device ","date":"2023-08-26","objectID":"/2023/08/2023-08-26-raspberry-pi-4-console/:4:0","tags":["arm","arm64","console","raspberrypi","linux"],"title":"Raspberry Pi 4 Console","uri":"/2023/08/2023-08-26-raspberry-pi-4-console/"},{"categories":["linux","arm","arm64"],"content":"參考資料 rpi4 預設的 dtb 這裡 disable-bt.dtbo 可以參照這裡 miniuart-bt.dtbo 可以參照這裡 default bt enable dts ","date":"2023-08-26","objectID":"/2023/08/2023-08-26-raspberry-pi-4-console/:5:0","tags":["arm","arm64","console","raspberrypi","linux"],"title":"Raspberry Pi 4 Console","uri":"/2023/08/2023-08-26-raspberry-pi-4-console/"},{"categories":["linux"],"content":"快速紀錄一下研究 firewalld, nftables, iptables 之間的關聯，還有坑。 ","date":"2023-04-12","objectID":"/2023/04/2023-04-12-firewalld-nftables-iptables/:0:0","tags":["linux","firewall","iptables","nftables","firewalld"],"title":"firewalld nftables iptables 之間的關聯","uri":"/2023/04/2023-04-12-firewalld-nftables-iptables/"},{"categories":["linux"],"content":"iptables 最早的 Linux 防火牆的指令，這邊只能算是前端指令跟語法，因為背後是 kernel module netfilter 處理的。這玩意已經被標註要棄用了，但是大家還是很習慣用這玩意。 ","date":"2023-04-12","objectID":"/2023/04/2023-04-12-firewalld-nftables-iptables/:1:0","tags":["linux","firewall","iptables","nftables","firewalld"],"title":"firewalld nftables iptables 之間的關聯","uri":"/2023/04/2023-04-12-firewalld-nftables-iptables/"},{"categories":["linux"],"content":"iptables-nft 現在很多 Linux distro 都會提供這個指令，把 iptables 的語法翻譯成 nft 的語法，然後再透過 nft 來設定。但是有一些坑，Debian, Ubuntu 這兩個可能還能用 iptables-nft 來設定防火牆，但是 RHEL, SUSE 系的可能就不行了。 ","date":"2023-04-12","objectID":"/2023/04/2023-04-12-firewalld-nftables-iptables/:1:1","tags":["linux","firewall","iptables","nftables","firewalld"],"title":"firewalld nftables iptables 之間的關聯","uri":"/2023/04/2023-04-12-firewalld-nftables-iptables/"},{"categories":["linux"],"content":"nftables 比較現代的防火牆語法跟指令，一樣是前端的部分而已，後端依然是 kernel module netfilter 處理。語法真的麻煩到靠北。 ","date":"2023-04-12","objectID":"/2023/04/2023-04-12-firewalld-nftables-iptables/:2:0","tags":["linux","firewall","iptables","nftables","firewalld"],"title":"firewalld nftables iptables 之間的關聯","uri":"/2023/04/2023-04-12-firewalld-nftables-iptables/"},{"categories":["linux"],"content":"firewalld Redhat 那個系列的，在 nft 之前，又套一個 firewalld 的控制。 ","date":"2023-04-12","objectID":"/2023/04/2023-04-12-firewalld-nftables-iptables/:3:0","tags":["linux","firewall","iptables","nftables","firewalld"],"title":"firewalld nftables iptables 之間的關聯","uri":"/2023/04/2023-04-12-firewalld-nftables-iptables/"},{"categories":["linux"],"content":"firewalld + nftables 的坑 firewalld 跟 nftables 如果放在一起，然後 distro 又同時提供 iptables-nft 了話，就會有個很大的坑在這邊。 firewalld 跟 nftables 這兩個本身都正常沒有問題，但是他們並沒有試圖設計成跟 iptables-nft 的向下相容，所以產生了坑。 iptables-nft 只能指定 filter/nat/mangle/raw 等等的 table 名稱，且這些 table 名稱就是在 netfilter 那個流程圖中提及的幾個 table，但是 nftables 把 table 名稱跟用途做了改變，可以允許多重且自訂名稱的 table。而 firewalld 直接將自己想要設定的規則，全部放在 table firewalld 裡面處理，也就是說你想要自己額外寫 nft 規則，其實可以開新的 table 同時去 hook 跟過去一樣的 table/chain 等等的。 因為 iptables-nft 是固定限制 table 名稱的，所以像是 RHEL/CentOS/Rocky Linux 這些紅帽系的 Linux 中使用的時候，會發現 iptables -n -L 什麼都沒顯示，但實際上有防火牆的運作。這是因為 iptables 沒使用 -t 指定 table 名稱的時候，預設是 filter ，但是你現在 nftables 裡面是沒有 table ip filter ，只有 table inet firewalld 的，所以就算看到 iptables 啥也沒有，但其實 nftables 裡面有一堆 firewalld 預先設定好的規則，所以會以為問題在其他地方。 至於 Debian/Ubuntu 系列的可能還能用 iptables 的原因，是因為這系列的防火牆規則直接把 nftables 的 table 結構設計成跟過去 iptables 時期的一樣，所以 iptables-nft 就能簡單的轉換規則顯示跟輸入了。 ","date":"2023-04-12","objectID":"/2023/04/2023-04-12-firewalld-nftables-iptables/:4:0","tags":["linux","firewall","iptables","nftables","firewalld"],"title":"firewalld nftables iptables 之間的關聯","uri":"/2023/04/2023-04-12-firewalld-nftables-iptables/"},{"categories":["linux"],"content":"結論 該學 nft 還是得學個 nft。不然哪天被坑死都不知道。 ","date":"2023-04-12","objectID":"/2023/04/2023-04-12-firewalld-nftables-iptables/:5:0","tags":["linux","firewall","iptables","nftables","firewalld"],"title":"firewalld nftables iptables 之間的關聯","uri":"/2023/04/2023-04-12-firewalld-nftables-iptables/"},{"categories":["lte"],"content":"簡單記錄下， debug 華為 Mini PCIe LTE module ME909s-821 在 Debian 上面的問題，同樣的可以套用到 VyOS 上面。 ","date":"2022-07-29","objectID":"/2022/07/usb_modeswitch_on_huawei_me909s/:0:0","tags":["lte","modem","udev"],"title":"USB Modeswitch on Huawei ME909s","uri":"/2022/07/usb_modeswitch_on_huawei_me909s/"},{"categories":["lte"],"content":"USB Modeswitch 華為的卡幾乎都是兩個以上的模式，有幾個系列的卡可能正常，但是 ME909s 相對起來只要切換設定檔而已，反而會造成 udev 一直重新被觸發，然後就卡住了。 ME909s 大部分都會想把 Configuration 從預設的 2 (cdc_ether) 轉換成 3 (cdc_mbim)，這時候就會需要 usb-modeswitch 的協助。 一般來說我們會新增一個檔案 /etc/usb_modeswitch.d/12d1:15c1 ，內容如下 Configuration=3 ","date":"2022-07-29","objectID":"/2022/07/usb_modeswitch_on_huawei_me909s/:1:0","tags":["lte","modem","udev"],"title":"USB Modeswitch on Huawei ME909s","uri":"/2022/07/usb_modeswitch_on_huawei_me909s/"},{"categories":["lte"],"content":"Issue 但是 usb-modeswitch 的 udev rule 沒有寫好，導致設定到一半就被中斷重新設定一次，進而導致設定失敗。 /lib/udev/usb_modeswitch 中會一直觸發到 systemctl restart usb-modeswitch@XXX.service ，所以 ME909s 被設定到一半就被中斷，第二次設定可能依然失敗，進而觸發第三次設定。 ","date":"2022-07-29","objectID":"/2022/07/usb_modeswitch_on_huawei_me909s/:2:0","tags":["lte","modem","udev"],"title":"USB Modeswitch on Huawei ME909s","uri":"/2022/07/usb_modeswitch_on_huawei_me909s/"},{"categories":["lte"],"content":"Fix (updated in 2022/07/31) 把 /lib/udev/rules.d/40-usb_modeswitch.rules 中的 SUBSYSTEM!=\"usb\", ACTION!=\"add\",, GOTO=\"modeswitch_rules_end\" 修改成 SUBSYSTEM!=\"usb\", GOTO=\"modeswitch_rules_end\" ACTION!=\"add\", GOTO=\"modeswitch_rules_end\" 順便發了個 patch 上 upstream 了，希望會收進去 https://www.draisberghof.de/usb_modeswitch/bb/viewtopic.php?f=2\u0026t=3034 ","date":"2022-07-29","objectID":"/2022/07/usb_modeswitch_on_huawei_me909s/:3:0","tags":["lte","modem","udev"],"title":"USB Modeswitch on Huawei ME909s","uri":"/2022/07/usb_modeswitch_on_huawei_me909s/"},{"categories":["lte"],"content":"Fix (old) 把 /lib/udev/rules.d/40-usb_modeswitch.rules 中的 # Huawei ME906, ME909 (MBIM, dummy config) ATTR{idVendor}==\"12d1\", ATTR{idProduct}==\"15c1\", RUN+=\"usb_modeswitch '/%k'\" 修改成 # Huawei ME906, ME909 (MBIM, dummy config) ACTION==\"add\", ATTR{idVendor}==\"12d1\", ATTR{idProduct}==\"15c1\", RUN+=\"usb_modeswitch '/%k'\" ","date":"2022-07-29","objectID":"/2022/07/usb_modeswitch_on_huawei_me909s/:4:0","tags":["lte","modem","udev"],"title":"USB Modeswitch on Huawei ME909s","uri":"/2022/07/usb_modeswitch_on_huawei_me909s/"},{"categories":["workaround"],"content":"快速紀錄一下，這幾天玩弄 SAF51003I/SAF51002I02 心得 最主要還是紀錄要怎麼讓 ESXi 可以安裝在這個平台上面 ","date":"2022-07-26","objectID":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/:0:0","tags":["esxi","intel","com","console"],"title":"SAF51003I, SAF51002I02, Intel C3000 Esxi Installation","uri":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/"},{"categories":["workaround"],"content":"ESXi 6.7 serial Installation 先用 Rufus 製作成 USB ，然後在修改 EFI\\boot\\boot.cfg 在 kernelopt=... 後面新增 gdbPort=none logPort=none tty2Port=com2 就可以存檔，並且使用 EFI 開機了 這邊我只測過 EFI ， Legacy BIOS Boot 不知道為甚麼不太成功 Note 一般來說應該會使用 COM1 ，但是我們遇到下面 Intel C3000 沒有 Legacy COM Port 的問題，而 ESXi 只支援 Legacy COM ","date":"2022-07-26","objectID":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/:1:0","tags":["esxi","intel","com","console"],"title":"SAF51003I, SAF51002I02, Intel C3000 Esxi Installation","uri":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/"},{"categories":["workaround"],"content":"Firmware Bug 0x3e2e0000 基本上這問題是因為開啟了 IOMMU / VT-d 的功能所導致的，只是說不知道為什麼 BIOS 推送記憶體的範圍表的時候會推送錯誤的訊息。 尋找以下的 BIOS 設定之後 IntelRCSetup \u003eNorth Bridge Chipset Configuration \u003eMemory config DFX Menu \u003e MMIO Size / BMBOUND Base 修改成從 auto 修改成 3072 / 1024M，基本上就可以完工了。 ","date":"2022-07-26","objectID":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/:2:0","tags":["esxi","intel","com","console"],"title":"SAF51003I, SAF51002I02, Intel C3000 Esxi Installation","uri":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/"},{"categories":["workaround"],"content":"Console 按鍵沒反應 因為 Intel C3000 並沒有辦法設定成 Legacy COM (IO=3F8H,IRQ=4) ，從 BIOS SIO 設定會一直被重設回去原本的狀態。 無意間發現，設定成 IO=2F8H,IRQ=3,4,5,6,7,9,10 這選項，會自動分配 IRQ=3 給 COM1 做使用。 而 IO=2F8H,IRQ=3 則是代表 Legacy COM 2 的 IO Port 以及 IRQ ， 所以變成我們直接把 COM1 透過 AMI SIO 的中斷指定，直接偽裝成 OS 中的 COM2 來使用，這樣就能透過原本的 serial console 來做相關的操作了 Advanced \u003e SIO \u003e Serial 1 將 auto ，修改成 IO=2F8H,IRQ=3,4,5,6,7,8,9,10; DMA ","date":"2022-07-26","objectID":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/:3:0","tags":["esxi","intel","com","console"],"title":"SAF51003I, SAF51002I02, Intel C3000 Esxi Installation","uri":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/"},{"categories":["workaround"],"content":"ESXi 進階設定 ESXi 預設還是會透過 VGA 的方式來給 TTY 跟 Console 操作畫面，所以我們需要先連接網路線，讓我們能先連接到 ESXi 的網頁設定，並從 進階設定 中搜尋 tty2Port ，修改設定為 com2 ，並重開機，就能在 serial console 操作 ESXi 相關的設定了。 ","date":"2022-07-26","objectID":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/:4:0","tags":["esxi","intel","com","console"],"title":"SAF51003I, SAF51002I02, Intel C3000 Esxi Installation","uri":"/2022/07/saf51003i-saf51002i02-intel-c3000-esxi-installation/"},{"categories":["life"],"content":"總之是個值得紀念的第一個文章 ","date":"2022-07-09","objectID":"/2022/07/first-post/:0:0","tags":["life"],"title":"First Post","uri":"/2022/07/first-post/"},{"categories":["vmware","server","vm"],"content":"VMware 的 vSwitch 中有以下三個選項可以讓你使用 MAC Address Changes Forged Transmits Promiscuous Mode Operation 主要是為了讓 VM 內的流量可以正常出來而需要選擇的，一般來說如果是要做 VM in VM了話，直接將三個一次打開是最簡單的處理方案。 這邊就依據三個分別去簡單解釋不同意義 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e Overview MAC Address Changes Forged Transmits Promiscuous Mode Operation VM in VM Ref ","date":"2021-10-22","objectID":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/:0:0","tags":null,"title":"VMware vSwitch MAC Address Changes, Forged Transmits, Promiscuous Mode Operation","uri":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/"},{"categories":["vmware","server","vm"],"content":"Overview 首先是，VMware 中的 vSwitch 並沒有 MAC Learning 的功能，所有 MAC 與 Switch Port 的對應，都是由 ESXi 或是 vCenter 靜態寫入的。意思就是，今天如果 VM 裡面有多組 MAC address ，例如說：macvlan, macvtap，vSwitch 並不會學習到這個額外 MAC 與 Switch Port 的對應。這某方面來說是安全考量。 ","date":"2021-10-22","objectID":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/:1:0","tags":null,"title":"VMware vSwitch MAC Address Changes, Forged Transmits, Promiscuous Mode Operation","uri":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/"},{"categories":["vmware","server","vm"],"content":"MAC Address Changes VM 的描述檔案中會記錄所有網卡的 MAC Address，ESXi 會直接根據這個檔案去填寫 vSwitch 的 MAC Table，進而透過這個表去發送封包。但是今天如果 VM 內部更改了 MAC Address 並發送資料，預設並不會更新 MAC Table，所以資料就無法正確地傳送到 VM 的 Port。 啟用這功能，則可以讓 VM 更改 MAC Address 並發送封包的時候，將 MAC Table 中的原本地址取代為新的地址。 注意：這邊並沒有新增 MAC Table 的紀錄，而是取代原本的紀錄。 ","date":"2021-10-22","objectID":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/:2:0","tags":null,"title":"VMware vSwitch MAC Address Changes, Forged Transmits, Promiscuous Mode Operation","uri":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/"},{"categories":["vmware","server","vm"],"content":"Forged Transmits ESXi 預設會比對從 VM 出來至 vSwitch 的來源 MAC Address 是否與 MAC Table 中的對應相符，若不相符則丟棄封包。 啟用這功能，則可以讓 VM 送出非記錄中的 MAC Address 封包，且 vSwitch 會略過檢查直接放行。 注意：這邊只關注 VM 到 vSwitch 的封包，反向的封包則依原本 MAC Table 處理，所以即使可以發送出去，但是因為 MAC Table 沒有更新或是新增紀錄，所以回程的封包則會被 vSwitch 丟棄。 ","date":"2021-10-22","objectID":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/:3:0","tags":null,"title":"VMware vSwitch MAC Address Changes, Forged Transmits, Promiscuous Mode Operation","uri":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/"},{"categories":["vmware","server","vm"],"content":"Promiscuous Mode Operation 因為 MAC Table 不會更新或新增，所以即使能夠正常送出封包，封包也無法正確回到原本 VM 上面。此選項會關閉所有 RX 方向的 Filter，將所有封包傳送至啟用此功能的網卡中 請用這功能，會設定該 Port Group 或是 vSwitch 的 Mirror 功能，所有流量都會送往啟用該功能的網卡中。大部分用於網路行為的測試與觀察。 注意：會類似關閉 MAC Table 功能，讓 vSwitch 接近 Hub ，可能導致效能降低。 ","date":"2021-10-22","objectID":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/:4:0","tags":null,"title":"VMware vSwitch MAC Address Changes, Forged Transmits, Promiscuous Mode Operation","uri":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/"},{"categories":["vmware","server","vm"],"content":"VM in VM 一般來說會考慮到這些功能的可能性，大部分是 VM in VM，就例如說想要測試不同種類的 Hypervisor ，就會在 VMware 內部再啟用巢狀虛擬化，並且在網卡上面需要分配給 VM 中的 VM。就會需要將上述功能都打開，才會正常運作。 但是 VMware 並不建議 VM in VM。 ","date":"2021-10-22","objectID":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/:5:0","tags":null,"title":"VMware vSwitch MAC Address Changes, Forged Transmits, Promiscuous Mode Operation","uri":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/"},{"categories":["vmware","server","vm"],"content":"Ref https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.security.doc/GUID-3507432E-AFEA-4B6B-B404-17A020575358.html https://williamlam.com/2018/04/native-mac-learning-in-vsphere-6-7-removes-the-need-for-promiscuous-mode-for-nested-esxi.html ","date":"2021-10-22","objectID":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/:6:0","tags":null,"title":"VMware vSwitch MAC Address Changes, Forged Transmits, Promiscuous Mode Operation","uri":"/2021/10/2021-10-22-vmware-vswitch-mac-address-changes-forged-transmits-promiscuous-mode-operation/"},{"categories":["network"],"content":"簡單紀錄一下使用Loopback IP的經驗。現在因為我用wireguard把宿舍、家裡還有雲端那邊串連在一起，所以路由變得滿複雜的，借用OSPF的便利把路由直接動態設定，但是這時候就遇到說router-id其實就滿不容易命名的清楚，可以一眼得知現在的路由是哪一個設備處理的。就目前看來以及其他同事給的設定guideline，似乎滿常透過Loopback IP作為這台設備的唯一識別號碼，更精確說是這個VRF的唯一識別。所以在router-id上面設定Loopback IP，就可以確定一定是哪一個設備，不用設定point to point的兩個IP，而且可能還會設定錯誤。 之後可能要研究一下能不能在wireguard上面使用到OSPF的unnumbered特性，這樣應該連IP設定都不太需要了，不過unnumbered這件事似乎是看routing engine決定的，所以如果都是FRR相同版本可能沒問題，但是有其他設備介入了話，就需要花時間測試看看了。 ","date":"2021-08-27","objectID":"/2021/08/2021-08-27-router-loopback-ip/:0:0","tags":null,"title":"Router Loopback IP使用","uri":"/2021/08/2021-08-27-router-loopback-ip/"},{"categories":["arm"],"content":"之前大學時期因為想玩玩 ARM64 Cloud 的緣故，所以找到了這台 Applied Micro 的 Mustang 原型機，可是大學時期一直沒有機會弄到一台 Mustang 來操作。直到最近廠商在清倉庫的時候，感謝 Richard Liu 直接幫我留了一台下來研究，而有這篇文章 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e Flash to UEFI bootloader Setup MAC address \u003cli class=\"ez-toc-page-1 ez-toc-heading-level-2\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"https://blog.kojuro.date/2021/02/applied-micro-x-gene-mustang-%e4%bd%bf%e7%94%a8%e5%bf%83%e5%be%97/#Install_Ubuntu_2004_arm64\" title=\"Install Ubuntu 20.04 arm64\"\u003eInstall Ubuntu 20.04 arm64\u003c/a\u003e\u003cul class=\"ez-toc-list-level-3\"\u003e \u003cli class=\"ez-toc-heading-level-3\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"https://blog.kojuro.date/2021/02/applied-micro-x-gene-mustang-%e4%bd%bf%e7%94%a8%e5%bf%83%e5%be%97/#flash-kernel_bug\" title=\"flash-kernel bug\"\u003eflash-kernel bug\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli class=\"ez-toc-page-1 ez-toc-heading-level-2\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"https://blog.kojuro.date/2021/02/applied-micro-x-gene-mustang-%e4%bd%bf%e7%94%a8%e5%bf%83%e5%be%97/#Result\" title=\"Result\"\u003eResult\u003c/a\u003e \u003c/li\u003e \u003cli class=\"ez-toc-page-1 ez-toc-heading-level-2\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"https://blog.kojuro.date/2021/02/applied-micro-x-gene-mustang-%e4%bd%bf%e7%94%a8%e5%bf%83%e5%be%97/#Reference\" title=\"Reference\"\u003eReference\u003c/a\u003e \u003c/li\u003e ","date":"2021-02-27","objectID":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/:0:0","tags":null,"title":"Applied Micro X-Gene Mustang 使用心得","uri":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/"},{"categories":["arm"],"content":"Flash to UEFI bootloader 認識我的人應該都知道，我極度討厭 ARM 開發板上面的 U-boot 作為開機引導，U-boot 開機的方式太多種類了，導致每次拿到新的板子都要研究一番，就例如說： Raspberry Pi 1 U-Boot 使用 kernel.img 作為名稱與格式 ORDOID-XU4 U-Boot 安裝在 SD 卡最前面的 sector，開機時會直接讀取 SD 卡作為開機引導，仿造 X86 BIOS 模式進行 U-Boot 需要指定 uImage 與 initrd.img Other ARM Board 這就要看廠商用哪種模式了 所以 U-Boot 對我來說，是一個討厭到不行的存在，除了 Kernel 需要不同格式跟安裝方式，有時候還需要指定特定的記憶體位置把 Kernel 讀取進去，然後再開機。 感謝 Marcin Juszkiewicz 提供的教學 [1]1 ，讓我可以把 Mustang 刷成 UEFI 開機的模式，而不需要浪費生命跟 U-Boot 戰鬥。請直接參閱 Marcin 提供的教學 blog，並且記得要同時更新 UEFI firmware 以及 Slimpro Firmware。 ","date":"2021-02-27","objectID":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/:1:0","tags":null,"title":"Applied Micro X-Gene Mustang 使用心得","uri":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/"},{"categories":["arm"],"content":"Setup MAC address 發現更新完 UEFI，mac address 在每次開機的時候會填入隨機值，所以需要在 UEFI shell 中設定 set MAC0 aa:bb:cc:dd:ee:f1 set MAC1 aa:bb:cc:dd:ee:f2 set MAC2 aa:bb:cc:dd:ee:f3 set MAC3 aa:bb:cc:dd:ee:f4 需要把 mac address 替換成你機器上面的條碼編號，並依序遞增 ","date":"2021-02-27","objectID":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/:1:1","tags":null,"title":"Applied Micro X-Gene Mustang 使用心得","uri":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/"},{"categories":["arm"],"content":"Install Ubuntu 20.04 arm64 安裝 Ubuntu 也是另外一個障礙，Ubuntu 有提供 arm64 安裝光碟，但是我發現 Live Installer 無法正常安裝，目前沒看到 log ，只有看到可能是 flash kernel 的時候遇到問題，目前猜可能是 Ubuntu 判定到是 APM-mustang 的機型之後，會認定使用 U-boot ，所以會順便使用 flash kernel 去安裝 Kernel 跟 DTB，所以 Live server 版本的安裝光碟無法使用。需要使用 Ubuntu arm64 netboot 的安裝 ISO [2]2 ，連結2中的 mini.iso 可以使用來安裝，只是安裝過程中必須要連接網路，才有辦法透過網路安裝。直接將 mini.iso 透過 dd 或是 Win32diskimager 寫入隨身碟中，並且插入 Mustang ，執行以下指令就可以進入 Ubuntu 安裝畫面 fsX:\\efi\\boot\\bootaa64.efi 請自行替換 fsX 成 UEFI 中你的隨身碟的代號 ","date":"2021-02-27","objectID":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/:2:0","tags":null,"title":"Applied Micro X-Gene Mustang 使用心得","uri":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/"},{"categories":["arm"],"content":"flash-kernel bug flash-kernel bug 經過一番 trace 之後發現很可能是因為 apm-mustang 過去一直都是 U-boot support，所以即便改成 UEFI 之後，flash-kernel 還是會認定需要透過 U-boot 方式開機。所以發了一個可能可以改善的 PR [3]3 結果 flash-kernel bug 並不是 root cause，也不是 fatal error。這問題是 flash-kernel 行為，以及 APT 行為，再加上 Curtin 行為，三者一起才會發生影響的。等待跟開發者討論之後再來決定怎麼紀錄好了。 ","date":"2021-02-27","objectID":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/:2:1","tags":null,"title":"Applied Micro X-Gene Mustang 使用心得","uri":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/"},{"categories":["arm"],"content":"Result ","date":"2021-02-27","objectID":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/:3:0","tags":null,"title":"Applied Micro X-Gene Mustang 使用心得","uri":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/"},{"categories":["arm"],"content":"Reference https://marcin.juszkiewicz.com.pl/2015/11/18/unbricking-apm-mustang/ http://free.nchc.org.tw/ubuntu-ports/dists/focal/main/installer-arm64/current/legacy-images/ https://salsa.debian.org/installer-team/flash-kernel/-/merge_requests/27 ","date":"2021-02-27","objectID":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/:4:0","tags":null,"title":"Applied Micro X-Gene Mustang 使用心得","uri":"/2021/02/2021-02-27-applied-micro-x-gene-mustang/"},{"categories":["server","arm"],"content":"因為之前在使用 ARM Server ，核心數高達 96 ，所以 Golang 的軟體預設就會使用 96 個程序，有時候就會讓 docker 卡卡的，很難使用，問題會超級多。之前使用 Kolla-Ansible 部署 OpenStack 的時候就經常遇到 Gather Facts 卡住，ARM Server 本身必須要重新啟動才會正常的情況。 所以建議用 GOMAXPROCS 把 docker.service 與 containerd.service 的程序使用量限制在一個合理範圍，目前看起來設定 GOMAXPROCS=4 ，dockerd 與 containerd 都還是會複製成 12 個程序，所以我設定為 GOMAXPROCS=12 ，讓程序使用量為 36 左右，目前測試起來沒有太大的問題。 ","date":"2019-03-19","objectID":"/2019/03/2019-03-20-too-many-cores-docker-problem/:0:0","tags":null,"title":"核心數太多導致的 Docker 問題","uri":"/2019/03/2019-03-20-too-many-cores-docker-problem/"},{"categories":["recovery"],"content":"因為 NWA1123-AC 的 WebUI 在 Chrome 下面沒辦法正常顯示，只能使用 Edge，相當不方便，所以就手賤去更新韌體，然後失敗了，完全開不了機。所以有了這篇修復筆記 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e 準備 正題 Ref ","date":"2019-03-01","objectID":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/:0:0","tags":null,"title":"Zyxel NWA1123-AC 修復筆記","uri":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/"},{"categories":["recovery"],"content":"準備 要先準備 Serial 線，需要三條杜邦線，以及 USB to TTL 或是 Raspberry Pi 一張，我自己是用 Banana Pi M2 。 Windows 的電腦一台並安裝 tftpd [1]，負責 tftp server，使用 Linux 作為 tftp server 都會失敗，不知道為什麼。 從 Zyxel 官網下載 NWA1123-AC 的 firmware [2]。並將 V212AAOX0C0.bin 重新命名為 V212AAOX0C0.tar.bz2，並解壓縮成 vmlinux_mi124_f1e.lzma.uImage 與 mi124_f1e-jffs2 ，並放入 tftpd 的資料夾中。 ","date":"2019-03-01","objectID":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/:1:0","tags":null,"title":"Zyxel NWA1123-AC 修復筆記","uri":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/"},{"categories":["recovery"],"content":"正題 先將 NWA1123-AC 斷電並拆殼，天線是固定在上蓋，要小心不要扯到線，依照 OpenWrt 的說明 [3] 接上 GND 、 RX 、 TX，Vcc 則忽略，若以 OpenWrt 圖所示，最右邊針腳為 GND ，由右向左依序為 GND、RX、TX。 然後連接 Serial ，並將 NWA1123-AC 上電，並於 Serial 多按幾次任意按鈕，進入 U-Boot 的操作介面。並參考這兩篇教學 [4,5] # setenv ipaddr \u003cAP IP\u003e # setenv serverip \u003cWindows IP\u003e # run lk # run lf 等待完成後就可以將 NWA1123-AC 重開機，並確認是否能使用了。 也可以直接在 U-Boot 操作執行 # run bootcmd 就能直接開機測試了。 ","date":"2019-03-01","objectID":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/:2:0","tags":null,"title":"Zyxel NWA1123-AC 修復筆記","uri":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/"},{"categories":["recovery"],"content":"Ref [1] http://tftpd32.jounin.net/ [2] https://www.zyxel.com/tw/zh/support/DownloadLandingSR.shtml?c=tw\u0026l=zh\u0026kbid=M-01949\u0026md=NWA1123-AC [3] https://oldwiki.archive.openwrt.org/toh/zyxel/nwa1123-ac#serial [4] https://blog.edhayes.us/2017/10/06/fixing-my-zyxel-nwa1123-ac/ [5] https://kb.zyxel.com/KB/searchArticle!gwsViewDetail.action?articleOid=014292\u0026lang=EN ","date":"2019-03-01","objectID":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/:3:0","tags":null,"title":"Zyxel NWA1123-AC 修復筆記","uri":"/2019/03/2019-03-02-zyxel-nwa1123-ac-recovery/"},{"categories":["backup"],"content":"因為之前蓋雲的緣故，所以資料總是得備份，而且資料有點大量，所以就寫一篇來說我現在怎麼備份到 G Suite 上面的。 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e 目前架構 Google Drive File Stream Windows Server 2019 WSL 總結 Ref ","date":"2019-02-17","objectID":"/2019/02/2019-02-17-auto-backup-g-suite/:0:0","tags":null,"title":"自動備份至 G Suite","uri":"/2019/02/2019-02-17-auto-backup-g-suite/"},{"categories":["backup"],"content":"目前架構 我現在是用 OMV 與 zfs 建立一個 NAS，所以我備份的時候只需要透過 zfs snapshot 與 zfs send 的功能，就能當資料寫成一個映像檔，但是因為資料量太大，動輒上 TB ，所以我會把映像檔每 100G 分割成一個檔案，比較有利於儲存等等項目。 主要先用 zfs snapshot ，定期快照，然後透過 zfs send 與 split 把資料分割 zfs snapshot -R zpool@$DATE zfs send -R zpool@$DATE | split -d -a 3 -b 100G - \"zpool@$DATE.\" ","date":"2019-02-17","objectID":"/2019/02/2019-02-17-auto-backup-g-suite/:1:0","tags":null,"title":"自動備份至 G Suite","uri":"/2019/02/2019-02-17-auto-backup-g-suite/"},{"categories":["backup"],"content":"Google Drive File Stream Google Drive File Stream (後稱：gfs)，這是只有 G Suite 帳號才能使用的功能，就是在 Windows 或是 macOS 底下模擬一個類似硬碟的設計，跟 rclone mount 或是 google-drive-ocamlfuse 有點類似。不過不支援 Linux ，也不支援多使用者操作。那在 Windows Server 上面則要多加一個參數才能正確安裝。 GoogleDriveFSSetup.exe --allow_server_install 在 Windows Server 中只能有一個帳戶啟用 gfs 功能，沒有辦法多人使用 [1]，且必須要設定足夠的 Cache 資料夾暫存，否則 gfs 會拒絕儲存該檔案。 簡單來說 gfs 會將檔案，先透過 FUSE 的方式儲存在 Local Disk 裡面，然後再上傳至 Google Drive，上傳完畢後再將 Local Disk 中的空間釋放，所以如果上傳速度沒有跟上，那就會先佔用到 Local Disk 的空間。 ","date":"2019-02-17","objectID":"/2019/02/2019-02-17-auto-backup-g-suite/:2:0","tags":null,"title":"自動備份至 G Suite","uri":"/2019/02/2019-02-17-auto-backup-g-suite/"},{"categories":["backup"],"content":"Windows Server 2019 那因為 gfs 無法用在 Linux 環境中，而且手上的 Server 都沒辦法安裝 Windows 10 或是 macOS，所以我就使用 Windows Server 2019 作為上傳工具。先安裝 gfs 之後，順便安裝 WSL，這是 Server 2019 新加入的功能，相當好用。 我的配置大概是，4TB 硬碟六顆做 Soft RAID0，然後把 gfs Cache 設定在上面。因為不想要浪費 NAS 上面的空間來儲存 zfs image ，所以在 Windows Server 中新增一個資料夾，並且開啟 NFS，作為 zfs image 的暫存點，NAS 那邊就會透過 zfs send ，直接儲存 zfs image 到 Windows Server 上面。這邊要注意 Windows Server NFS 會將 wsize 與 rsize 都設定為 1048576 ，所以很可能會超級吃 NAS 上面的 OS Cache，壓縮到 zfs 能使用的記憶體，不過使用上並沒有什麼太多的影響。網路傳輸方面則會累積一定快取之後，才真正寫入 Windows Server ，這點要注意一下。 當複製到 RAID 的 zfs image 暫存點之後，就可以透過 FastCopy [2]，這套在 Windows 上面可以正常複製 UTF-16 檔名、過長檔名的檔案們，而且速度不算太慢，GUI 使用也算方便，不過我還是以 script 使用為主。例如可以這樣 FastCopy.exe /cmd=move /estimate /acl=FALSE /stream=FALSE /reparse=FALSE /verify=FALSE /recreate /error_stop=FALSE /no_ui /ballonn=FALSE /force_start \"$SRC_A\" \"$SRC_B\" /to=G:\\我的雲端硬碟\\zfs_backup\\ ","date":"2019-02-17","objectID":"/2019/02/2019-02-17-auto-backup-g-suite/:3:0","tags":null,"title":"自動備份至 G Suite","uri":"/2019/02/2019-02-17-auto-backup-g-suite/"},{"categories":["backup"],"content":"WSL 接下來介紹 WSL 相對比較好用的使用方式，如果在 Powershell 上面使用，可能會覺得字體等等的不便，所以使用 Cmder 或是單單使用 ConEmu ，搭配 ConEmu 內建的 WSLbridge.exe ，可以正常的使用方向鍵，與愉快的終端機顯示。[3] WSL 有一個最為終極的好處，針對我們這種喜愛 Linux Script 的使用者，又同時需要 Windows exe 功能的時候。如果你在 WSL 中呼叫一個 Windows EXE ，依然會正常執行，所以既可以享受到方便的 scripting ，又可以直接使用 Native Windows EXE，算是一舉兩得。 /mnt/c/Users/Administrator/FastCopy/FastCopy.exe XXX XXX ","date":"2019-02-17","objectID":"/2019/02/2019-02-17-auto-backup-g-suite/:4:0","tags":null,"title":"自動備份至 G Suite","uri":"/2019/02/2019-02-17-auto-backup-g-suite/"},{"categories":["backup"],"content":"總結 總結的來說，script 大概會長這個樣子，只要定期在 Windows Server 中執行 autocopy.sh，就可以自動備份到 gfs 上面了。 不過上傳可能會遇到每日上傳 750G 的限制，以及 Cache 的資料夾容量不足等等的問題，也必須要記得將 zfs snapshot 適時的刪除過舊的版本，以免造成效能低落。 上傳速度約為 300 ~ 420Mbps，比 Synology Cloud Sync 20 threads 慢(可以到 1Gbps)，但是 Synology Cloud Sync 容易發生建立成兩個同名資料夾，檔案就分散在兩邊的問題。至於 rclone 等等的 Linux 同步軟體，我都不太確定在遇到上傳限制時，該如何 fallback 。所以才直接採用 Google File Stream，雖然速度相對慢一些，但是資料比較正確上傳。 # autocopy.sh in windows wsl #!/bin/bash # -*- coding: utf-8 -*- DATE=`date +%Y%m%d` echo $DATE #ssh -i ~/id.pem $USER@$IP \"sudo /root/autosnapshot.sh $DATE\" ssh -t -i ~/id.pem $USER@$IP \"sudo screen -m /root/autosnapshot.sh $DATE\" SRC_DIR='H:\\zfs_backup\\' SRC=\"$SRC_DIR\\\\zpool@$DATE\" /mnt/c/Users/Administrator/FastCopy/FastCopy.exe \\ /cmd=move \\ /estimate \\ /acl=FALSE \\ /stream=FALSE \\ /reparse=FALSE \\ /verify=FALSE \\ /recreate \\ /error_stop=FALSE \\ /no_ui \\ /balloon=FALSE \\ /force_start \\ \"$SRC\" \\ '/to=G:\\我的雲端硬碟\\zfs_backup\\' # /root/autosnapshot.sh in NAS #!/bin/bash echo $1 if [ ! -n $1 ]; then echo \"Need Date YYYYMMDD!\" exit 1 fi POOL=zpool DATE=$1 TARGET=/tmp/zfs_backup # check if this snapshot exsits if ! zfs list -t all | grep \"$POOL@$DATE\" \u003e /dev/null 2\u003e\u00261 ; then echo \"There is no snapshot. Snapshot now\" zfs snapshot -r \"$POOL@$DATE\" fi # send to zfs_backup mkdir -p \"$TARGET\" if ! mountpoint -q -- \"$TARGET\"; then mount -t nfs '$WINDOWS_IP:/zfs_backup' \"$TARGET\" fi mkdir -p \"$TARGET/$POOL@$DATE\" zfs send -R \"$POOL@$DATE\" | pv -trba | split -d -a 3 -b 100G - \"$TARGET/$POOL@$DATE/$POOL@$DATE.\" #zfs send -R \"$POOL@$DATE\" | split -d -a 3 -b 100G - \"$TARGET/$POOL@$DATE/$POOL@$DATE.\" ","date":"2019-02-17","objectID":"/2019/02/2019-02-17-auto-backup-g-suite/:5:0","tags":null,"title":"自動備份至 G Suite","uri":"/2019/02/2019-02-17-auto-backup-g-suite/"},{"categories":["backup"],"content":"Ref https://www.reddit.com/r/DataHoarder/comments/8rye2n/there_is_a_simple_way_of_installing_google_drive/ https://fastcopy.jp/en/ https://conemu.github.io/en/BashOnWindows.html ","date":"2019-02-17","objectID":"/2019/02/2019-02-17-auto-backup-g-suite/:6:0","tags":null,"title":"自動備份至 G Suite","uri":"/2019/02/2019-02-17-auto-backup-g-suite/"},{"categories":["clonezilla","ezio","bt"],"content":"這篇就隨便打打吧。就是篇剛剛幫國網中心 debug 完的心得。 當初就只是很單純覺得 CloneZilla Multicast Mode 為甚麼速度這麼不穩，而研究並思考可以用什麼方案取代，沒想到黃秉鈞學長隨口講講的 BT Solution ，最後真的被我跟我室友顏靖軒做出來了。從 2016 年底開發至今，總算是迎來第一個完整且穩定的 CloneZilla Bittorrent Mode (\u003e=2.6.1-2 or 20190123-* amd64)。附上國網中心蕭志榥研究員做的教學文件。 可是做完這個之後，我卻沒有任何地方可以真的大規模測試，畢竟我從一開始就不是做網管的，所以也只好請大家幫忙測試看看啦。 Clonezilla live 2.6.1-2 The underlying GNU/Linux operating system was upgraded. This release is based on the Debian Sid repository (as of 2019/Jan/22). Enable secure boot support when creating Debian live system (create-debian-live). However, it's still not ready for secure boot: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=920144 Add nuttcp as an alternative to netcat in ocs-onthefly. Add dialog for choosing compression algorithm in expert mode. Option \"-u\" was added in the dialog of expert mode to use nuttcp. Bug fixed: For CentOS 7, the ncat need the option \"--recv-only\" in the client. To avoid OOM killer to kill ezio, we use the multi torrent files support (ezio \u003e= 1.1.6) and limit the cache size. It can be tuned by ezio_cache_ratio in drbl-ocs.conf. Add a mechanism to reuse image for BT from disk mode. The option -mdst-img can be used to assign the existing pseudo image. New mechanism was added: instead of using Partclone image as the BT source, the local device (whole disk or partitions) can be as the source, too. -- Steven Shiau \u003csteven at clonezilla org\u003e Tue, 22 Jan 2019 22:47:00 +0800 ","date":"2019-01-31","objectID":"/2019/01/2019-01-31-clonezilla-bittorrent-deploy/:0:0","tags":["clonezilla","ezio","bt","bittorrent"],"title":"CloneZilla Bittorrent Deploy","uri":"/2019/01/2019-01-31-clonezilla-bittorrent-deploy/"},{"categories":["server"],"content":"最近在測試 CloneZilla EZIO 模式，想說自己有三台 server 閒置，那就拿來跑看看，結果沒想到有一張網卡沒有辦法 PXE 開機，所以只好研究下怎麼處理了。 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e 解決方式 ","date":"2019-01-31","objectID":"/2019/01/2019-01-31-intel-82599es-10g-enable-pxe/:0:0","tags":null,"title":"Intel 82599ES 10G 網卡啟用 PXE","uri":"/2019/01/2019-01-31-intel-82599es-10g-enable-pxe/"},{"categories":["server"],"content":"解決方式 先下載 82599ES 的 firmware，應該會得到一個 IBABUILD.exe 的 DOS 執行檔，然後在透過 DOS 執行編譯還有 flash firmware，就可以搞定了。指令有點忘記了，之後想到在補。 ","date":"2019-01-31","objectID":"/2019/01/2019-01-31-intel-82599es-10g-enable-pxe/:1:0","tags":null,"title":"Intel 82599ES 10G 網卡啟用 PXE","uri":"/2019/01/2019-01-31-intel-82599es-10g-enable-pxe/"},{"categories":["arm"],"content":"因為之前大學時期都在玩一些開發板，例如說 Raspberry Pi 等等的項目，所以朋友 Jalen 買了 Banana Pi W2 的一些問題就跑來問我，所以才有這些心路歷程 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e 前情 開發板爆炸時代 困境 Open Source？ ","date":"2018-12-30","objectID":"/2018/12/2018-12-31-arm-developboard/:0:0","tags":["arm","developboard"],"title":"最近 ARM 開發板的一些心得","uri":"/2018/12/2018-12-31-arm-developboard/"},{"categories":["arm"],"content":"前情 Banana Pi W2 的功能有 HDMI Input 與硬體的 H.264 編碼，可以做為擷取卡或是直接當作實況機來用，所以我個人滿有興趣的，畢竟身為開發者，有時候會有開發者的傲氣，認為買現成的產品（例如說：圓剛的擷取卡系列）就輸了，也因為市面上擷取卡等等產品也不便宜，例如說：BlackMagic 的系列產品就不便宜。 而且，如果只買圓剛的產品，就沒有會只有擷取功能，事實上還要搭配電腦做後製（上圖片或是上聊天畫面甚麼的），也要透過電腦做軟體或硬體的 H.264 編碼，才能透過 RTMP 傳送到 Twitch 等等的實況平台，事實上來說也沒有說非常的方便。當然以一個專業的實況主而言，這些都是必要的支出。而我是開發者，有傲氣的開發者，所以我們當然是會選擇比較硬派的方式，雖然說結果可能沒有直接買現成產品來的好，但是算是一種成就。 而後來因為 BPI-W2 使用的 RTD1296 晶片有太多沒 specs 而沒辦法處理的部分，所以我們轉向嘗試 RK3399，至少我們在網路上搜尋到的資訊量而言，RK3399 算是比較有希望的，而 Orange Pi RK3399 有提供一個有 HDMI IN 功能的 Debian Image，當然還是沒有抱太大希望。而真的拿到實品之後測試，確實發現 HDMI IN 並沒有辦法擷取到音訊，花非常多時間研究電路連接設計，參考 AIO-3399J 的電路連接，也參考公板音訊設計，最後還是因為對 ALSA 與 ASoC 的不熟悉而停止。 網路上有些 TC358749XBG 的文章，但大部分都支援 Android 而已，並沒有對 Linux 的支援做描述，更沒有提到該晶片 i2s 與 RT5651 相接的使用方式，即便詢問了 Rockchip 的開發者，卻看到一些與 RK Github 上些許不同的設計，而我沒有經驗與技術可以排除 conflict ，所以只好各種 trial and error，當然最終還是以失敗收場，Toshiba TC358749XBG 的晶片名稱我都 Google 到已經背下來的程度了。 說句實在話，我也沒有真的需要 HDMI IN 來擷取 PS4 遊戲畫面，我實況又不會有人看，真的要實況，直接買圓剛的 Solution 都比這個快速方便，我想這大概就是一種挑戰吧，很自虐的那種。 ","date":"2018-12-30","objectID":"/2018/12/2018-12-31-arm-developboard/:1:0","tags":["arm","developboard"],"title":"最近 ARM 開發板的一些心得","uri":"/2018/12/2018-12-31-arm-developboard/"},{"categories":["arm"],"content":"開發板爆炸時代 自從 Raspberry Pi 上市，而引起的自造風潮，不少開發者會認為 Raspberry Pi 的硬體效能不符合需求，進而導致了現在的開發板爆炸的時代，大概就跟羅傑的大航海時代差不多？ 好處就是，你想要什麼功能，大概市面上可能都可以找到相應的開發板，來開發自己所需，但是壞處就三言兩語沒辦法講清了。 ","date":"2018-12-30","objectID":"/2018/12/2018-12-31-arm-developboard/:2:0","tags":["arm","developboard"],"title":"最近 ARM 開發板的一些心得","uri":"/2018/12/2018-12-31-arm-developboard/"},{"categories":["arm"],"content":"困境 先提一下現在開發板的生態，有分成兩種 Linux 主體 Android 主體 為什麼會以這兩種為主體呢？是因為在 ARM 世界幾乎以 SoC 方式出現，所以通常會是 CPU Vendor 要準備所有 Driver ，而後 ODM 廠商而基於這些基礎上開發應用。那開發 Driver 的前提通常會以現有 ODM 廠商想要出什麼樣的產品，而決定優先開發 Android Driver 或是 Linux Driver ，這個在現今是非常巨大的差別，這會牽涉到 Android 與 Linux Kernel 授權不同的議題，因為我也沒有非常了解，所以就不細提，不過大致上問題而言，Android Driver 大部分是可以閉源的，就 Android 為了保護或是提供廠商使用的誘因而設計；而 Linux Kernel 在 GPL 授權之下，大部分都會以 GPL 方式釋出 Driver，對於廠商來說，這是一個他們不太喜歡的因素。 而且 Android 開發至今對於 UI/UX 等等的議題已經相當完整，也不需要針對系統方面去處理，所以 ODM 廠商相對會選擇 Android 作為他們開發特定應用的基礎，不會再從 Linux 開始重新造輪子。當然對於 Android 比較耗用資源這點，還是有些廠商認為是個問題，不過這都是相對比較少數，至少在我這邊提到的前提而言是比較少的。 在這個前提之下，CPU Vendor 通常會從 Android Driver 支援起，不一定打算支援 Linux ，也不一定有人力能做支援。Android Driver 不一定能跟 Linux 通用，這點是要注意的，即便 Android 是基於 Linux Kernel 的設計，但是還是有不少部分已經差距過於遙遠了。 所以在 CPU Vendor 沒有提供 Linux 支援的情況下，開發板廠商就會面臨限制，畢竟對於開發板廠商而言，通常他們只具備應用開發，與不同元件之間的軟體支援，但是對於 SoC 本身的支援通常要仰賴 CPU Vendor，所以就會遇到很多開發板，上面只有純 AOSP ，而 Linux Image 爛到一種極點的問題。 ","date":"2018-12-30","objectID":"/2018/12/2018-12-31-arm-developboard/:3:0","tags":["arm","developboard"],"title":"最近 ARM 開發板的一些心得","uri":"/2018/12/2018-12-31-arm-developboard/"},{"categories":["arm"],"content":"Open Source？ 事實上在 Linux 上支援爛，也不純然是因為 GPL 問題，有非常多方法可以規避 GPL 在 Driver 上的問題。主要還是人力問題，各種 Cost Down 文化，進而導致對 Open Source 又愛又恨，也是現在台灣不少公司所面臨到的難題之一。 對於硬體廠商而言，做支援是賺不了什麼錢的，今天開一顆新的晶片，沒賣出一定數量級，是很可能虧本的。所以不提 Open Source Driver，甚至連 Linux 支援都不一定有，ODM 廠商想要什麼功能，才去開發出什麼功能。永續發展才是真的，沒有利益收入，哪來的支援。 所以對於網路上某些小朋友（對，我用小朋友這詞，因為他們確實年紀都比我小，而且都是剛接觸開源的新人）形容閉源軟體就如邪惡一般，不忍說這已經是對開源的崇拜接近到邪教的程度。當然開源解決了相當多的問題，但是並非萬靈丹，總是會踢到鐵板的。 就我而言，如果說軟體可以完全不靠其他人的貢獻，而做到非常的完美，那我並不需要要求什麼開源，因為我可以不需要自己處理問題，都會有支援幫忙把這些處理完畢。那很明顯的，在商業環境中，就需要極大量的人力與金錢來支持，才有辦法做到。 那就會有不少公司沒有這麼深的口袋可以做到這點，就會站在巨人的肩膀上做更多，所以就會基於 Open Source 軟體，而去開發他們的產品。 但是，就是這個但是，有太多廠商用了 Open Source 卻不照授權方式處理，所以你就會注意到他們用了開源軟體，改了開源軟體但是沒有依授權規定釋出他們修改的內容，這相當令人詬病。不忍說，我會注意到他們修改開源軟體，也是因為遇到 bug ，想尋找問題在哪裡的時候發現居然有太多沒有出現在原始碼的片段。可以很明顯的看到 binary 中有相當大量的 Vendor Name 出現，而沒有看到他們有提出原始碼。 這點就讓我非常的不能接受，我可以接受閉源，畢竟有些還是技術之所在，但是我不能接受在利用社會的貢獻之後，又不依照規則將之回饋給社會。 ","date":"2018-12-30","objectID":"/2018/12/2018-12-31-arm-developboard/:4:0","tags":["arm","developboard"],"title":"最近 ARM 開發板的一些心得","uri":"/2018/12/2018-12-31-arm-developboard/"},{"categories":["openstack"],"content":"我透過 OpenMediaVault 搭配 OMV-zfs plugin 使用 zfs ，UI 能使用的功能依舊很少，所以大部分還是得用 CLI 控制 ZFS 本身，不過可以用 OMV UI 控制很多 file sharing 的設定就已經萬謝了。以下分享一些，使用 ZFS 以來的心得。 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e ZFS on Debian 系統配置 硬碟規劃 L2ARC ZIL VMware on ZFS NFSv3 iSCSI \u003cli class=\"ez-toc-page-1 ez-toc-heading-level-2\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"https://blog.kojuro.date/2018/10/zfs-%e4%bd%bf%e7%94%a8%e7%9a%84%e7%b6%93%e9%a9%97/#Reference\" title=\"Reference\"\u003eReference\u003c/a\u003e \u003c/li\u003e ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:0:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"ZFS on Debian Debian 透過 DKMS 的方式動態編譯與載入 ZFS Module，以規避 ZFS 與 Linux Kernel License 不相容的問題，所以每次更新 ZFS 或是 Kernel ，都會有很長一段編譯時間要等待。 ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:1:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"系統配置 CPU: E5-2620v2 x2 RAM: DDR3 ECC REG 48G HDD: Toshiba HDD 4T 5900RPM x12 HBA: LSI-2308 (有點忘了) Network: Intel Dual 10G ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:2:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"硬碟規劃 目前硬碟規劃都是 3 顆硬碟做成 RAIDZ1，用 12 顆硬碟作 4 組，後再做 RAID0 NAME STATE READ WRITE CKSUM zpool ONLINE 0 0 0 raidz1-0 ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46TAK2K1FNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46T2K63RFNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46T1K2V4FNWA ONLINE 0 0 0 raidz1-1 ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46M4K3ZOFNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46T2K63DFNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46TBK183FNWA ONLINE 0 0 0 raidz1-2 ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46TAK2K5FNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_86F1K3B4FNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46T1K2V7FNWA ONLINE 0 0 0 raidz1-3 ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46TBK184FNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46T1K2V6FNWA ONLINE 0 0 0 ata-TOSHIBA_MD03ACA400V_46TAK2KAFNWA ONLINE 0 0 0 ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:3:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"L2ARC 當你記憶體足夠大的時候，事實上 L2ARC 也沒有甚麼太大作用，對於 4K 讀寫加速也沒有特別顯著，基本上 Cache 的量大約都只有記憶體大小而已，用太大的 SSD 沒什麼幫助以外，甚至可能還會占用一個硬碟空間，記憶體大於 32G 之後，就沒有那麼划算了。除非 Server 背面有 2.5 吋硬碟的槽位，但通常這情況將系統碟做成 RAID1 可能會比較實際。 ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:4:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"ZIL 若使用 async mode 來開啟檔案，ZIL 在這情境就完全不會發揮作用。還沒有測試過 iSCSI 是否也會相同，未來可以測試看看。 測試過後，iSCSI 透過 LIO 處理，並沒有任何使用到 ZIL 的跡象，可能還是因為 async mode 的緣故 ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:5:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"VMware on ZFS ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:6:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"NFSv3 透過 NFSv3 來提供 VMware ESXi 存放，以上面那種配置而言，在上面安裝 Windows Server 2016 ，測試速度大概如下： 基本上 L2ARC 與 ZIL 都沒有發揮作用 ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:6:1","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"iSCSI 這邊我就直接測試透過 Windows 10 直接存取 iSCSI 的效能 ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:6:2","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"Reference Configuring ZFS Cache for High Speed IO ","date":"2018-10-20","objectID":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/:7:0","tags":null,"title":"ZFS 使用的經驗","uri":"/2018/10/zfs-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B6%93%E9%A9%97/"},{"categories":["openstack"],"content":"Kolla 多少還是有一些不合需求的地方，我們可以透過 Kolla Template 的方式修改 Dockerfile ，不用直接硬修改 Kolla 本身，而是透過 Kolla 提供的 Plugin 安裝接口修正。 修改的同時可能需要一些 Jinja (Template Engine) 的一些知識，可以參考 Jinja 官網的文件，也需要 Dockerfile 的撰寫知識。 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e 簡單教學 泛用 Template Reference ","date":"2018-10-18","objectID":"/2018/10/patch-kolla-via-template/:0:0","tags":null,"title":"Patch Kolla via Template","uri":"/2018/10/patch-kolla-via-template/"},{"categories":["openstack"],"content":"簡單教學 可以修改的地方非常多，我這邊就講解最簡單的 Patch 項目。 一般而言我們上 Patch 都會在最後的最後，才把我們修正的部分加進去，避免中間操作，又把我們修正的部分還原。Kolla Dockerfile 中提供了 \u003cservice image\u003e-footer 的區塊，供我們插入 Plugin 或是其他額外的檔案設定。 就例如說前文，我們要修正 QEMU 的軟體包，那我們可以在 template-override.j2 這個檔案中修正 Nova-Libvirt 。 # in template-override.j2 {% extends parent_template %} {% block nova_libvirt_footer %} ADD \\ http://\u003csome ip\u003e/qemu-utils_2.11+dfsg-1ubuntu7.6_arm64.deb \\ /patch/ RUN dpkg -i /patch/*.deb {% endblock %} Kolla 建置 Image 的時候新增以下參數 tools/build.py --template-override template-override.j2 就可以在建置最後，直接將我們的修改好的 QEMU 直接加入其中 ","date":"2018-10-18","objectID":"/2018/10/patch-kolla-via-template/:1:0","tags":null,"title":"Patch Kolla via Template","uri":"/2018/10/patch-kolla-via-template/"},{"categories":["openstack"],"content":"泛用 Template 當然我們也可以直接撰寫一個泛用的 template，我的情境需要用到 x86_64 以及 arm64 兩種環境，所以我可以改成泛用的 template 以供使用。 {% extends parent_template %} {% set custom_patch_url = \"http://mgmt.kojuro.date:8000/\" %} {% set custom_patch_path = \"/patch/\" %} {% set custom_patch_version = \"2.11+dfsg-1ubuntu7.6\" %} {% set custom_patch_arch = \"amd64\" %} {% if base_arch == \"aarch64\" %} {% set custom_patch_arch = \"arm64\" %} {% endif %} {% block cinder_base_footer %} # qemu-utils qemu-block-extra ADD \\ {{ custom_patch_url }}/qemu-utils_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-block-extra_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_path }}/ RUN dpkg -i {{ custom_patch_path }}/*.deb {% endblock %} {% block nova_libvirt_footer %} # qemu qemu-block-extra # qemu-system qemu-user qemu-utils # qemu-system-arm qemu-system-mips qemu-system-ppc qemu-system-sparc qemu-system-x86 qemu-system-s390x qemu-system-misc # qemu-system-common ADD \\ {{ custom_patch_url }}/qemu-utils_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-arm_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-mips_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-ppc_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-sparc_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-x86_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-s390x_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-misc_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-system-common_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-user_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-block-extra_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_path }}/ RUN dpkg -i {{ custom_patch_path }}/*.deb {% endblock %} {% block nova_compute_footer %} # qemu-utils qemu-block-extra ADD \\ {{ custom_patch_url }}/qemu-utils_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-block-extra_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_path }}/ RUN dpkg -i {{ custom_patch_path }}/*.deb {% endblock %} {% block glance_api_footer %} # qemu-utils qemu-block-extra ADD \\ {{ custom_patch_url }}/qemu-utils_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_url }}/qemu-block-extra_{{ custom_patch_version}}_{{ custom_patch_arch }}.deb \\ {{ custom_patch_path }}/ RUN dpkg -i {{ custom_patch_path }}/*.deb {% endblock %} ","date":"2018-10-18","objectID":"/2018/10/patch-kolla-via-template/:2:0","tags":null,"title":"Patch Kolla via Template","uri":"/2018/10/patch-kolla-via-template/"},{"categories":["openstack"],"content":"Reference OpenStack Docs Building Container Images Dockerfile Customisation ","date":"2018-10-18","objectID":"/2018/10/patch-kolla-via-template/:3:0","tags":null,"title":"Patch Kolla via Template","uri":"/2018/10/patch-kolla-via-template/"},{"categories":["openstack"],"content":"OpenStack 通常會有兩種儲存 VM 的方式，一個是直接在 Nova-Compute Node 上面的 /var/lib/nova/instances ，另外一種則是儲存在 Cinder。前者通常也不會真的直接儲存在 Node 上，而是會透過 Shared Storage 儲存，例如 NFS 等等。 但是因為 OpenStack 會有一些 Lock 機制，偏偏 NFS 不一定實作全部的 Lock 種類，所以會導致 Lock 失敗，進而製作 VM 也跟著失敗。 Nova 在新增 VM 或是複製 Image 的時候，會考慮處理程序處理的問題，所以會使用 Lock ，以確保沒有正確無誤。透過 oslo.concurrency 處理 Lock，底層透過 fasteners 呼叫 fcntl ，進而失敗。所以我們將 Lock 機制暫時取消掉。目前還無法確定取消掉之後會不會有其他問題存在。 在 /etc/kolla/nova.conf 中，加入以下設定，將 Lock 關閉 # /etc/kolla/nova.conf [oslo_concurrency] disable_process_locking = True 接下來，直接在 Host 中掛載 NFS ，例如： # Nova-Compute Host mount -t nfs 172.x.x.x:/export/openstack /srv/nfs/openstack 然後設定 /etc/kolla/globals.yml ，掛載 NFS 目錄進 Container 之中 # /etc/kolla/globals.yml nova_instance_datadir_volume: \"/srv/nfs/openstack/\" 並且依據先前調整 Cinder-Volume NFS Driver，對 QEMU 相關的修改即可。 ","date":"2018-10-17","objectID":"/2018/10/2018-10-18-kolla-ansible-nova-ephemeral-storage-on-nfs/:0:0","tags":null,"title":"Kolla-Ansible Nova Ephemeral Storage on NFS","uri":"/2018/10/2018-10-18-kolla-ansible-nova-ephemeral-storage-on-nfs/"},{"categories":["openstack"],"content":"最近使用 Kolla-Ansible 部署 OpenStack Rocky on AArch64/ARM64 發生一些問題，這問題並不只是存在 ARM 上，而是因為發行版所維護的 QEMU 版本已經跟到了 commit ca749954b09b89e22cd69c4949fb7e689b057963 ，這個 commit 使用到了 F_OFD_SETLK， NFSv3 正好不支援這類型 lock 操作。 而這個修改，並沒有根據不同檔案系統不支援 F_OFD_SETLK 回退 F_SETLK 的操作，所以只要在現代 Linux 中編譯 QEMU，就會直接使用 F_OFD_SETLK ，而造成在 NFSv3 上無法使用 lock 進而導致失敗的現象。 而這問題也不單單只影響 Cinder-Volume，也間接影響 Nova-Compute，如果 VM 要掛載 Volume，而 Cinder 使用 NFS Driver，則會在 Nova-Compute 上也把 NFS 掛載上去給 QEMU 使用。 Table of Contents \u003cspan class=\"ez-toc-title-toggle\"\u003e\u003ca class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"\u003e\u003ci class=\"ez-toc-glyphicon ez-toc-icon-toggle\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/span\u003e Kolla Cinder NFSv3 Lock Failed 問題 解決方法 \u003cli class=\"ez-toc-page-1 ez-toc-heading-level-2\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"https://blog.kojuro.date/2018/10/openstack-rocky-cinder-nfs-driver-issue/#QEMU_Failed_to_lock_byte_100\" title=\"QEMU Failed to lock byte 100\"\u003eQEMU Failed to lock byte 100\u003c/a\u003e\u003cul class=\"ez-toc-list-level-3\"\u003e \u003cli class=\"ez-toc-heading-level-3\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"https://blog.kojuro.date/2018/10/openstack-rocky-cinder-nfs-driver-issue/#%E5%95%8F%E9%A1%8C-2\" title=\"問題\"\u003e問題\u003c/a\u003e \u003c/li\u003e \u003cli class=\"ez-toc-page-1 ez-toc-heading-level-3\"\u003e \u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"https://blog.kojuro.date/2018/10/openstack-rocky-cinder-nfs-driver-issue/#%E8%A7%A3%E6%B1%BA%E8%BE%A6%E6%B3%95\" title=\"解決辦法\"\u003e解決辦法\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e ","date":"2018-10-17","objectID":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/:0:0","tags":null,"title":"OpenStack Rocky Cinder NFS Driver Issue","uri":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/"},{"categories":["openstack"],"content":"Kolla Cinder NFSv3 Lock Failed ","date":"2018-10-17","objectID":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/:1:0","tags":null,"title":"OpenStack Rocky Cinder NFS Driver Issue","uri":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/"},{"categories":["openstack"],"content":"問題 Kolla Cinder 已經在 commit 17e6e629f5660a364498b2bfd2f5aa6aede79859 中開啟 NFS 功能，但是將 rpcbind 取消，NFSv4 已經不需要 rpcbind ，所以將他移出必要元件之一。 ","date":"2018-10-17","objectID":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/:1:1","tags":null,"title":"OpenStack Rocky Cinder NFS Driver Issue","uri":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/"},{"categories":["openstack"],"content":"解決方法 分兩種： 直接在 Host (包含 Cinder-Volume Host 以及 Nova-Compute Node)上安裝 rpcbind ，然後啟用，確保 rpcbind socket 位置在 /run ， Docker Container 也有 Mount Volume 安裝 rpcbind 的 Container ，直接 Container Volume Bind ","date":"2018-10-17","objectID":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/:1:2","tags":null,"title":"OpenStack Rocky Cinder NFS Driver Issue","uri":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/"},{"categories":["openstack"],"content":"QEMU Failed to lock byte 100 ","date":"2018-10-17","objectID":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/:2:0","tags":null,"title":"OpenStack Rocky Cinder NFS Driver Issue","uri":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/"},{"categories":["openstack"],"content":"問題 如果欲將 Image 轉換成 Volume 來使用的時候，會透過 qemu-img 來轉換，這過程如果目標地在 NFS 上，則會遇到我在開頭提及的問題，進而產生 QEMU Failed to lock byte 100 ","date":"2018-10-17","objectID":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/:2:1","tags":null,"title":"OpenStack Rocky Cinder NFS Driver Issue","uri":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/"},{"categories":["openstack"],"content":"解決辦法 建議是不要用 NFSv3 ，改用其他種 Backend 。雖然講的很不負責任，但是 NFSv3 事實上已經很久的技術了，雖然很成熟，但是已經不太符合現代 HA 等等需求，建議還是替換。個人也是因為經費因素，沒有辦法替換成 Ceph 或是其他的方案，則還是希望使用 NFS 作為 Cinder Backend，甚至 Nova instances_path 都希望直接在 NFS Storage 上。 若無法替換則使用下面方法。 重新編譯 QEMU ，強制取消使用 F_OFD_SETLK ，若使用 Ubuntu 等等的發行版，建議直接從發行版來源上 patch 重新編譯即可 apt build-dep qemu apt install -y fakeroot apt source qemu cd qemu/ # let macro will never be compiled # replace all \"#ifdef F_OFD_SETLK\" to \"#if 0\" sed -i.bak 's|def F_OFD_SETLK| 0|g' utils/osdep.c DEB_BUILD_OPTIONS=\"parallel=8\" fakeroot debian/rules clean binary # *.deb will place at ../ 編譯完之後，將打包好的 deb 放入 Container 中以便安裝，以下 Container 皆需要安裝新的 package ，似乎其他 OpenStack 模組也需要上 patch ，但是我沒有細看，所以只列出我有使用到的部分 nova_libvirt nova_compute cinder_api cinder_volume cinder_scheduler ls *.deb | xargs -i docker cp {} \u003cContainer Name\u003e:/var/lib/kolla/ 根據不同的 Container 安裝需要的 QEMU package 即可，並不需要全部安裝 docker exec -it -u root \u003cContainer Name\u003e bash # inside Container # Check installed QEMU package apt list --installed | grep qemu cd /var/lib/kolla/ # install patched qemu dpkg -i qemu-\u003csome need package name\u003e.deb 可能需要重新啟動 Container Nova-Libvirt，其餘部分就可以直接使用。 ","date":"2018-10-17","objectID":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/:2:2","tags":null,"title":"OpenStack Rocky Cinder NFS Driver Issue","uri":"/2018/10/2018-10-17-openstack-rocky-cinder-nfs-driver-issue/"},{"categories":["openstack"],"content":"OpenStack on AArch64/ARM64 已經可以透過 Kolla-Ansible 直接部署，一般在 x86_64 部署 OpenStack 可以參考 Gene Kuo 的部落格文章 ，我這邊就不再贅述。 這篇主要說明如何在 x86_64 與 Arm64 混合雲的情況下，透過 Kolla-Ansible 直接部署 OpenStack Rocky 並且可以正常使用。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:0:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"基礎架構 一個 HA 的 OpenStack 需要至少 4 個節點，分別為 3 個 control node ，與 1 個 compute node，每個節點至少需要 2 個網路介面，不過我下面會使用 3 個網路介面作為範例，將外部與內部的 API 使用分離。這邊使用 3 個 x86_64 control node，以及 1 個 ARM server 作為 compute node ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:1:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"網路介面 api_interface 為內部 API 使用的介面 neutron_external_interface 為 VM 或是其他 OpenStack 網路功能所對外的介面，無法使用 IP ，如果使用虛擬機則必須要允許這個介面使用 Promiscuous Mode kolla_external_vip_interface 為 HAProxy 所使用對外服務的介面 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:1:1","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"伺服器 Mgmt 作為 Kolla-Ansible 執行的環境 control01 ~ 03 為 OpenStack Control Node，為 x86 compute01 為 ARM server ，為OpenStack Compute Node ，欲執行 ARM VM ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:1:2","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"準備 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:2:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"Kolla Kolla 並沒有在 Docker Hub 上面預先準備 aarch64 的 image 給大家使用，所以我們必須要自行編譯 OpenStack Kolla image 給 aarch64 使用，於 ARM64 server 中執行 git clone https://github.com/openstack/kolla -b stable/rocky 因為 OpenStack Rocky 預設會透過 Libvirt 尋找可以 PCI Passthrough 以及 SR-IOV 的設備，但是 Libvirt 並無法正確判讀 Cavium ThunderX 網卡功能，所以我們將該功能直接從 OpenStack 之中去除，於 kolla/docker/nova/nova-compute/Dockerfile.j2 中，於 COPY extend_start.sh /usr/local/bin/kolla_nova_extend_start 之前加入以下 patch RUN rm -f /var/lib/kolla/venv/lib/python2.7/site-packages/nova/virt/libvirt/driver.pyc RUN sed -i \"/data\\['pci_passthrough_/d\" /var/lib/kolla/venv/lib/python2.7/site-packages/nova/virt/libvirt/driver.py RUN sed -i \"/self._get_pci_passthrough_devices()/d\" /var/lib/kolla/venv/lib/python2.7/site-packages/nova/virt/libvirt/driver.py 並且執行編譯並推送至自架的 Docker Registry 中，在這邊我們推薦來源為 source ，而非 binary (發行版維護) cd kolla tools/build.py --base ubuntu --base-arch aarch64 --tag rocky --type source --registry \u0026lt;Your Registry IP or Hostname\u0026gt;:5000 --push ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:2:1","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"Kolla-Ansible pip 中能夠安裝的 Kolla-Ansible 並沒有我們需要的版本，也因為要修改，所以直接使用 upstream 版本會相對方便許多 git clone https://github.com/openstack/kolla-ansible -b stable/rocky pip install -U ansible cp kolla-ansible/etc/kolla/ /etc/kolla 該版本似乎存在一些問題，導致 rabbitmq 沒有辦法正確識別參數，所以需要修正。這問題似乎在 commit 5bfcb584275 後修好了，可以考慮直接使用新版的 kolla-ansible cd kolla-ansible/ansible/roles grep -r transport_url | awk -F\":\" '{print $1}' | xargs -i sed -i 's|transport_url = {{ rpc_transport_url }}|transport_url = {{ rpc_transport_url }}/|g' {} grep -r transport_url | awk -F\":\" '{print $1}' | xargs -i sed -i 's|transport_url = {{ notify_transport_url }}|transport_url = {{ notify_transport_url }}/|g' {} ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:2:2","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"安裝設定 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:3:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"Kolla-Ansible 設定 Kolla-Ansible 的設定都會存在 /etc/kolla 之中，主要修改 /etc/kolla/globals.yml 來改變參數，此部分先參照 Gene Kuo 的教學文章，我未來再補上，要注意的是必須關閉 fluentd 功能，這功能目前無法用在 AArch64 上面。 enable_fluentd=\"no\" ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:3:1","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"Ansible Inventory 設定 我們先複製預設的多節點部署做為基底修改 cp kolla-ansible/ansible/inventory/multinode . 因為我們要部署混合平台的 OpenStack，即為 Control Node 為 x86 ，Compute Node 為 AArch64 ，我們會利用 multinode 這個 Inventory 覆蓋相關的設定，並確定你的 ansible user 可以不需要密碼直接使用 sudo [control] control[01:03] ansible_ssh_user=\u0026lt;username\u0026gt; ansible_become=True ansible_private_key_file=\u0026lt;priv key\u0026gt; neutron_external_interface=ens224 api_interface=ens192 storage_interface=ens192 tunnel_interface=ens192 remote_src=True [network:children] control [inner-compute] [external-compute] compute01 ansible_ssh_user=\u0026lt;username\u0026gt; ansible_become=True ansible_private_key_file=\u0026lt;priv key\u0026gt; neutron_external_interface=enP2p1s0f3 api_interface=enP2p1s0f2 storage_interface=enP2p1s0f2 tunnel_interface=enP2p1s0f2 docker_registry=\u0026lt;Your Registry IP\u0026gt;:5000 remote_src=True ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:3:2","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"部署 先產生 OpenStack 部署中所需要的所有密碼，密碼會在 /etc/kolla/passwords.yml 之中 cd kolla-ansible tools/generate_passwords.py 然後安裝必要套件，大部分不太會有意外，但是 AArch64 伺服器上不一定有辦法正確執行，所以推薦先行安裝 docker 與 python-dev 等等套件 tools/koll-ansible -i ../multinode bootstrap-servers 部署前測試，會測試相關資源是否被使用到 tools/kolla-ansible -i ../multinode prechecks 實際部署，會從 Registry 中拉取 image 使用，並且傳送設定檔至目標伺服器 tools/kolla-ansible -i ../multinode deploy ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:4:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"使用 若部署沒有出現問題，則可以使用 /etc/kolla/passwords.yml 中的 keystone_admin_password ，帳號為 admin 登入 OpenStack 介面 透過以下指令可以生產 CLI 使用比較方便的 openrc 予以使用，並存在 /etc/kolla/admin-openrc.sh 中 tools/kolla-ansible -i ../multinode post-deploy ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:5:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"OpenStack on AArch64 AArch64 會有一些跟 x86 不同的地方，因為 Linaro 已經做了相當多的修改，所以我們必要的修正只有少數一些設定 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:6:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"映像檔 開機映像檔需要新增一些參數，讓 AArch64 VM 可以正常運作，我們必須使用 UEFI 映像檔開機，以 Ubuntu Cloud Image 為例，16.04 需要下載檔名含有 uefi 的映像檔，18.04 以後則預設為 UEFI 開機 openstack image create \"image display name\" --file \"\u0026lt;image file\u0026gt;\" --disk-format qcow2 --container-format bare --property hw_scsi_model='virtio-scsi' --property hw_disk_bus='scsi' --property hw_firmware_type='uefi' --public ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:6:1","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"VNC Console AArch64 的顯示並非如 x86 直接使用 vga 設備，而是透過 virtio-gpu-pci 這外部裝置，Ubuntu Cloud Image 中的 Linux Kernel 並沒有預設啟用 virtio-gpu 這個模組，也並沒有預設安裝，所以在 VM 開機完畢之後，需要安裝 linux-modules-extra 的套件，並預設啟動模組以及修改設定。 於 /etc/default/grub 中，需修改 GRUB_CMDLINE_LINUX_DEFAULT=\"console=tty1\" 然後執行 sudo update-grub 安裝並預設啟用 virtio-gpu 模組，linux-image-extra-virtual 為虛擬套件，他會安裝其他必要模組 sudo apt install -y linux-image-extra-virtual 於 /etc/modules 中新增 virtio-gpu # /etc/modules: kernel modules to load at boot time. # # This file contains the names of kernel modules that should be loaded # at boot time, one per line. Lines beginning with \"#\" are ignored. virtio-gpu 並重新打包 initramfs sudo update-initramfs -u 重開機後即可於 AArch64 VM 正常使用 VNC console ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:6:2","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"後記 因為很無聊，所以在 VM 上面安裝了桌面環境來玩看看，但是因為沒有 GPU 加速，所以真的是滿慢的 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:7:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"},{"categories":["openstack"],"content":"Reference [1] 透過 Kolla-Ansible 跟 Container 部署 OpenStack ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/:8:0","tags":["openstack","arm64","aarch64"],"title":"Openstack on AArch64/Arm64 via Kolla Ansible","uri":"/2018/10/2018-10-14-openstack-on-aarch64-arm64-via-kolla-ansible/"}]